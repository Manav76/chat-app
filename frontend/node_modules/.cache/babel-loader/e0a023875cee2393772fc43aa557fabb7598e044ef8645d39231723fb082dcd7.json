{"ast":null,"code":"var _jsxFileName = \"/Users/surajpurohit/Desktop/chat-app/frontend/src/components/chat/ChatLayout.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport Sidebar from './Sidebar';\nimport ChatHeader from './ChatHeader';\nimport ChatWindow from './ChatWindow';\nimport MessageInput from './MessageInput';\nimport { useAuth } from '../../context/AuthContext';\nimport './Chat.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ChatLayout = () => {\n  _s();\n  const [sessions, setSessions] = useState([]);\n  const [currentSession, setCurrentSession] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [streamingMessage, setStreamingMessage] = useState(null);\n  const {\n    getAuthHeader\n  } = useAuth();\n  const eventSourceRef = useRef(null);\n\n  // Fetch chat sessions\n  useEffect(() => {\n    const fetchSessions = async () => {\n      setIsLoading(true);\n      try {\n        const response = await fetch('http://localhost:8000/chat/sessions', {\n          headers: getAuthHeader()\n        });\n        if (response.ok) {\n          const data = await response.json();\n          setSessions(data);\n\n          // If there are sessions and no current session is selected, select the first one\n          if (data.length > 0 && !currentSession) {\n            setCurrentSession(data[0]);\n          }\n        }\n      } catch (error) {\n        console.error('Error fetching sessions:', error);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n    fetchSessions();\n  }, [getAuthHeader, currentSession]);\n\n  // Fetch messages for the current session\n  useEffect(() => {\n    const fetchMessages = async () => {\n      if (!currentSession) return;\n      setIsLoading(true);\n      try {\n        const response = await fetch(`http://localhost:8000/chat/sessions/${currentSession.id}`, {\n          headers: getAuthHeader()\n        });\n        if (response.ok) {\n          const data = await response.json();\n          setMessages(data.messages || []);\n        }\n      } catch (error) {\n        console.error('Error fetching messages:', error);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n    fetchMessages();\n  }, [currentSession, getAuthHeader]);\n\n  // Handle session selection\n  const handleSessionSelect = session => {\n    setCurrentSession(session);\n  };\n\n  // Handle new session creation\n  const handleNewSession = async () => {\n    try {\n      const response = await fetch('http://localhost:8000/chat/sessions', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...getAuthHeader()\n        },\n        body: JSON.stringify({\n          title: 'New Chat'\n        })\n      });\n      if (response.ok) {\n        const newSession = await response.json();\n        setSessions([newSession, ...sessions]);\n        setCurrentSession(newSession);\n        setMessages([]);\n      }\n    } catch (error) {\n      console.error('Error creating new session:', error);\n    }\n  };\n\n  // Handle session deletion\n  const handleDeleteSession = async sessionId => {\n    try {\n      const response = await fetch(`http://localhost:8000/chat/sessions/${sessionId}`, {\n        method: 'DELETE',\n        headers: getAuthHeader()\n      });\n      if (response.ok) {\n        // Remove the session from the list\n        const updatedSessions = sessions.filter(session => session.id !== sessionId);\n        setSessions(updatedSessions);\n\n        // If the current session was deleted, select another one or set to null\n        if (currentSession && currentSession.id === sessionId) {\n          setCurrentSession(updatedSessions.length > 0 ? updatedSessions[0] : null);\n          setMessages([]);\n        }\n      }\n    } catch (error) {\n      console.error('Error deleting session:', error);\n    }\n  };\n\n  // Handle sending a message\n  const handleSendMessage = async message => {\n    if (!message.trim()) return;\n    setIsLoading(true);\n\n    // Create a temporary message object for the user's message\n    const userMessage = {\n      id: `temp-${Date.now()}`,\n      content: message,\n      role: 'user',\n      created_at: new Date().toISOString()\n    };\n\n    // Add the user message to the messages array\n    setMessages(prevMessages => [...prevMessages, userMessage]);\n    try {\n      // Prepare the request body\n      const requestBody = {\n        message: message,\n        session_id: currentSession === null || currentSession === void 0 ? void 0 : currentSession.id\n      };\n\n      // Start the streaming request\n      const response = await fetch('http://localhost:8000/chat/stream', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...getAuthHeader()\n        },\n        body: JSON.stringify(requestBody)\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || 'Failed to send message');\n      }\n\n      // Create a reader for the stream\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n\n      // Create a temporary message for streaming\n      const tempAssistantMessage = {\n        id: `temp-assistant-${Date.now()}`,\n        content: '',\n        role: 'assistant',\n        created_at: new Date().toISOString()\n      };\n      setStreamingMessage(tempAssistantMessage);\n      let sessionId = null;\n      let messageId = null;\n\n      // Read the stream\n      while (true) {\n        const {\n          done,\n          value\n        } = await reader.read();\n        if (done) {\n          break;\n        }\n\n        // Decode the chunk and split by newlines\n        const chunk = decoder.decode(value, {\n          stream: true\n        });\n        const lines = chunk.split('\\n').filter(line => line.trim());\n        for (const line of lines) {\n          try {\n            const data = JSON.parse(line);\n            if (data.type === 'session_id') {\n              sessionId = data.session_id;\n\n              // If we don't have a current session, create one\n              if (!currentSession) {\n                const sessionResponse = await fetch(`http://localhost:8000/chat/sessions/${sessionId}`, {\n                  headers: getAuthHeader()\n                });\n                if (sessionResponse.ok) {\n                  const sessionData = await sessionResponse.json();\n                  setCurrentSession(sessionData);\n\n                  // Update the sessions list\n                  fetchSessions();\n                }\n              }\n            } else if (data.type === 'content') {\n              // Update the streaming message content\n              setStreamingMessage(prev => ({\n                ...prev,\n                content: prev.content + data.content\n              }));\n            } else if (data.type === 'message_id') {\n              messageId = data.message_id;\n            } else if (data.type === 'error') {\n              throw new Error(data.error);\n            }\n          } catch (e) {\n            console.error('Error parsing stream chunk:', e);\n          }\n        }\n      }\n\n      // When streaming is complete, add the final message to the messages array\n      if (messageId) {\n        // Replace the streaming message with the final message\n        setMessages(prevMessages => [...prevMessages.filter(m => m.id !== tempAssistantMessage.id), {\n          ...tempAssistantMessage,\n          id: messageId\n        }]);\n      }\n\n      // Clear the streaming message\n      setStreamingMessage(null);\n\n      // Refresh the messages if needed\n      if (currentSession) {\n        fetchMessages(currentSession.id);\n      }\n    } catch (error) {\n      console.error('Error sending message:', error);\n      // Show error to user\n      alert(`Error: ${error.message}`);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"chat-layout\",\n    children: [/*#__PURE__*/_jsxDEV(Sidebar, {\n      sessions: sessions,\n      currentSession: currentSession,\n      onSessionSelect: handleSessionSelect,\n      onNewSession: handleNewSession,\n      onDeleteSession: handleDeleteSession,\n      isLoading: isLoading\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 262,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"chat-main\",\n      children: [/*#__PURE__*/_jsxDEV(ChatHeader, {\n        currentSession: currentSession\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 271,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(ChatWindow, {\n        messages: messages,\n        streamingMessage: streamingMessage,\n        currentSession: currentSession,\n        isLoading: isLoading\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 274,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(MessageInput, {\n        onSendMessage: handleSendMessage\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 280,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 270,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 261,\n    columnNumber: 5\n  }, this);\n};\n_s(ChatLayout, \"XLrtFdFl/nkK8A2pzNnCaru0rCg=\", false, function () {\n  return [useAuth];\n});\n_c = ChatLayout;\nexport default ChatLayout;\nvar _c;\n$RefreshReg$(_c, \"ChatLayout\");","map":{"version":3,"names":["React","useState","useEffect","useRef","Sidebar","ChatHeader","ChatWindow","MessageInput","useAuth","jsxDEV","_jsxDEV","ChatLayout","_s","sessions","setSessions","currentSession","setCurrentSession","messages","setMessages","isLoading","setIsLoading","streamingMessage","setStreamingMessage","getAuthHeader","eventSourceRef","fetchSessions","response","fetch","headers","ok","data","json","length","error","console","fetchMessages","id","handleSessionSelect","session","handleNewSession","method","body","JSON","stringify","title","newSession","handleDeleteSession","sessionId","updatedSessions","filter","handleSendMessage","message","trim","userMessage","Date","now","content","role","created_at","toISOString","prevMessages","requestBody","session_id","errorData","Error","detail","reader","getReader","decoder","TextDecoder","tempAssistantMessage","messageId","done","value","read","chunk","decode","stream","lines","split","line","parse","type","sessionResponse","sessionData","prev","message_id","e","m","alert","className","children","onSessionSelect","onNewSession","onDeleteSession","fileName","_jsxFileName","lineNumber","columnNumber","onSendMessage","_c","$RefreshReg$"],"sources":["/Users/surajpurohit/Desktop/chat-app/frontend/src/components/chat/ChatLayout.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport Sidebar from './Sidebar';\nimport ChatHeader from './ChatHeader';\nimport ChatWindow from './ChatWindow';\nimport MessageInput from './MessageInput';\nimport { useAuth } from '../../context/AuthContext';\nimport './Chat.css';\n\nconst ChatLayout = () => {\n  const [sessions, setSessions] = useState([]);\n  const [currentSession, setCurrentSession] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [streamingMessage, setStreamingMessage] = useState(null);\n  \n  const { getAuthHeader } = useAuth();\n  const eventSourceRef = useRef(null);\n\n  // Fetch chat sessions\n  useEffect(() => {\n    const fetchSessions = async () => {\n      setIsLoading(true);\n      try {\n        const response = await fetch('http://localhost:8000/chat/sessions', {\n          headers: getAuthHeader()\n        });\n        \n        if (response.ok) {\n          const data = await response.json();\n          setSessions(data);\n          \n          // If there are sessions and no current session is selected, select the first one\n          if (data.length > 0 && !currentSession) {\n            setCurrentSession(data[0]);\n          }\n        }\n      } catch (error) {\n        console.error('Error fetching sessions:', error);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    fetchSessions();\n  }, [getAuthHeader, currentSession]);\n\n  // Fetch messages for the current session\n  useEffect(() => {\n    const fetchMessages = async () => {\n      if (!currentSession) return;\n      \n      setIsLoading(true);\n      try {\n        const response = await fetch(`http://localhost:8000/chat/sessions/${currentSession.id}`, {\n          headers: getAuthHeader()\n        });\n        \n        if (response.ok) {\n          const data = await response.json();\n          setMessages(data.messages || []);\n        }\n      } catch (error) {\n        console.error('Error fetching messages:', error);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    fetchMessages();\n  }, [currentSession, getAuthHeader]);\n\n  // Handle session selection\n  const handleSessionSelect = (session) => {\n    setCurrentSession(session);\n  };\n\n  // Handle new session creation\n  const handleNewSession = async () => {\n    try {\n      const response = await fetch('http://localhost:8000/chat/sessions', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...getAuthHeader()\n        },\n        body: JSON.stringify({\n          title: 'New Chat'\n        })\n      });\n      \n      if (response.ok) {\n        const newSession = await response.json();\n        setSessions([newSession, ...sessions]);\n        setCurrentSession(newSession);\n        setMessages([]);\n      }\n    } catch (error) {\n      console.error('Error creating new session:', error);\n    }\n  };\n\n  // Handle session deletion\n  const handleDeleteSession = async (sessionId) => {\n    try {\n      const response = await fetch(`http://localhost:8000/chat/sessions/${sessionId}`, {\n        method: 'DELETE',\n        headers: getAuthHeader()\n      });\n      \n      if (response.ok) {\n        // Remove the session from the list\n        const updatedSessions = sessions.filter(session => session.id !== sessionId);\n        setSessions(updatedSessions);\n        \n        // If the current session was deleted, select another one or set to null\n        if (currentSession && currentSession.id === sessionId) {\n          setCurrentSession(updatedSessions.length > 0 ? updatedSessions[0] : null);\n          setMessages([]);\n        }\n      }\n    } catch (error) {\n      console.error('Error deleting session:', error);\n    }\n  };\n\n  // Handle sending a message\n  const handleSendMessage = async (message) => {\n    if (!message.trim()) return;\n    \n    setIsLoading(true);\n    \n    // Create a temporary message object for the user's message\n    const userMessage = {\n      id: `temp-${Date.now()}`,\n      content: message,\n      role: 'user',\n      created_at: new Date().toISOString()\n    };\n    \n    // Add the user message to the messages array\n    setMessages(prevMessages => [...prevMessages, userMessage]);\n    \n    try {\n      // Prepare the request body\n      const requestBody = {\n        message: message,\n        session_id: currentSession?.id\n      };\n      \n      // Start the streaming request\n      const response = await fetch('http://localhost:8000/chat/stream', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...getAuthHeader()\n        },\n        body: JSON.stringify(requestBody)\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || 'Failed to send message');\n      }\n      \n      // Create a reader for the stream\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n      \n      // Create a temporary message for streaming\n      const tempAssistantMessage = {\n        id: `temp-assistant-${Date.now()}`,\n        content: '',\n        role: 'assistant',\n        created_at: new Date().toISOString()\n      };\n      \n      setStreamingMessage(tempAssistantMessage);\n      \n      let sessionId = null;\n      let messageId = null;\n      \n      // Read the stream\n      while (true) {\n        const { done, value } = await reader.read();\n        \n        if (done) {\n          break;\n        }\n        \n        // Decode the chunk and split by newlines\n        const chunk = decoder.decode(value, { stream: true });\n        const lines = chunk.split('\\n').filter(line => line.trim());\n        \n        for (const line of lines) {\n          try {\n            const data = JSON.parse(line);\n            \n            if (data.type === 'session_id') {\n              sessionId = data.session_id;\n              \n              // If we don't have a current session, create one\n              if (!currentSession) {\n                const sessionResponse = await fetch(`http://localhost:8000/chat/sessions/${sessionId}`, {\n                  headers: getAuthHeader()\n                });\n                \n                if (sessionResponse.ok) {\n                  const sessionData = await sessionResponse.json();\n                  setCurrentSession(sessionData);\n                  \n                  // Update the sessions list\n                  fetchSessions();\n                }\n              }\n            } else if (data.type === 'content') {\n              // Update the streaming message content\n              setStreamingMessage(prev => ({\n                ...prev,\n                content: prev.content + data.content\n              }));\n            } else if (data.type === 'message_id') {\n              messageId = data.message_id;\n            } else if (data.type === 'error') {\n              throw new Error(data.error);\n            }\n          } catch (e) {\n            console.error('Error parsing stream chunk:', e);\n          }\n        }\n      }\n      \n      // When streaming is complete, add the final message to the messages array\n      if (messageId) {\n        // Replace the streaming message with the final message\n        setMessages(prevMessages => [\n          ...prevMessages.filter(m => m.id !== tempAssistantMessage.id),\n          {\n            ...tempAssistantMessage,\n            id: messageId\n          }\n        ]);\n      }\n      \n      // Clear the streaming message\n      setStreamingMessage(null);\n      \n      // Refresh the messages if needed\n      if (currentSession) {\n        fetchMessages(currentSession.id);\n      }\n    } catch (error) {\n      console.error('Error sending message:', error);\n      // Show error to user\n      alert(`Error: ${error.message}`);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"chat-layout\">\n      <Sidebar \n        sessions={sessions}\n        currentSession={currentSession}\n        onSessionSelect={handleSessionSelect}\n        onNewSession={handleNewSession}\n        onDeleteSession={handleDeleteSession}\n        isLoading={isLoading}\n      />\n      <div className=\"chat-main\">\n        <ChatHeader \n          currentSession={currentSession} \n        />\n        <ChatWindow \n          messages={messages} \n          streamingMessage={streamingMessage}\n          currentSession={currentSession}\n          isLoading={isLoading}\n        />\n        <MessageInput onSendMessage={handleSendMessage} />\n      </div>\n    </div>\n  );\n};\n\nexport default ChatLayout; "],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,QAAQ,EAAEC,SAAS,EAAEC,MAAM,QAAQ,OAAO;AAC1D,OAAOC,OAAO,MAAM,WAAW;AAC/B,OAAOC,UAAU,MAAM,cAAc;AACrC,OAAOC,UAAU,MAAM,cAAc;AACrC,OAAOC,YAAY,MAAM,gBAAgB;AACzC,SAASC,OAAO,QAAQ,2BAA2B;AACnD,OAAO,YAAY;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEpB,MAAMC,UAAU,GAAGA,CAAA,KAAM;EAAAC,EAAA;EACvB,MAAM,CAACC,QAAQ,EAAEC,WAAW,CAAC,GAAGb,QAAQ,CAAC,EAAE,CAAC;EAC5C,MAAM,CAACc,cAAc,EAAEC,iBAAiB,CAAC,GAAGf,QAAQ,CAAC,IAAI,CAAC;EAC1D,MAAM,CAACgB,QAAQ,EAAEC,WAAW,CAAC,GAAGjB,QAAQ,CAAC,EAAE,CAAC;EAC5C,MAAM,CAACkB,SAAS,EAAEC,YAAY,CAAC,GAAGnB,QAAQ,CAAC,KAAK,CAAC;EACjD,MAAM,CAACoB,gBAAgB,EAAEC,mBAAmB,CAAC,GAAGrB,QAAQ,CAAC,IAAI,CAAC;EAE9D,MAAM;IAAEsB;EAAc,CAAC,GAAGf,OAAO,CAAC,CAAC;EACnC,MAAMgB,cAAc,GAAGrB,MAAM,CAAC,IAAI,CAAC;;EAEnC;EACAD,SAAS,CAAC,MAAM;IACd,MAAMuB,aAAa,GAAG,MAAAA,CAAA,KAAY;MAChCL,YAAY,CAAC,IAAI,CAAC;MAClB,IAAI;QACF,MAAMM,QAAQ,GAAG,MAAMC,KAAK,CAAC,qCAAqC,EAAE;UAClEC,OAAO,EAAEL,aAAa,CAAC;QACzB,CAAC,CAAC;QAEF,IAAIG,QAAQ,CAACG,EAAE,EAAE;UACf,MAAMC,IAAI,GAAG,MAAMJ,QAAQ,CAACK,IAAI,CAAC,CAAC;UAClCjB,WAAW,CAACgB,IAAI,CAAC;;UAEjB;UACA,IAAIA,IAAI,CAACE,MAAM,GAAG,CAAC,IAAI,CAACjB,cAAc,EAAE;YACtCC,iBAAiB,CAACc,IAAI,CAAC,CAAC,CAAC,CAAC;UAC5B;QACF;MACF,CAAC,CAAC,OAAOG,KAAK,EAAE;QACdC,OAAO,CAACD,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;MAClD,CAAC,SAAS;QACRb,YAAY,CAAC,KAAK,CAAC;MACrB;IACF,CAAC;IAEDK,aAAa,CAAC,CAAC;EACjB,CAAC,EAAE,CAACF,aAAa,EAAER,cAAc,CAAC,CAAC;;EAEnC;EACAb,SAAS,CAAC,MAAM;IACd,MAAMiC,aAAa,GAAG,MAAAA,CAAA,KAAY;MAChC,IAAI,CAACpB,cAAc,EAAE;MAErBK,YAAY,CAAC,IAAI,CAAC;MAClB,IAAI;QACF,MAAMM,QAAQ,GAAG,MAAMC,KAAK,CAAC,uCAAuCZ,cAAc,CAACqB,EAAE,EAAE,EAAE;UACvFR,OAAO,EAAEL,aAAa,CAAC;QACzB,CAAC,CAAC;QAEF,IAAIG,QAAQ,CAACG,EAAE,EAAE;UACf,MAAMC,IAAI,GAAG,MAAMJ,QAAQ,CAACK,IAAI,CAAC,CAAC;UAClCb,WAAW,CAACY,IAAI,CAACb,QAAQ,IAAI,EAAE,CAAC;QAClC;MACF,CAAC,CAAC,OAAOgB,KAAK,EAAE;QACdC,OAAO,CAACD,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;MAClD,CAAC,SAAS;QACRb,YAAY,CAAC,KAAK,CAAC;MACrB;IACF,CAAC;IAEDe,aAAa,CAAC,CAAC;EACjB,CAAC,EAAE,CAACpB,cAAc,EAAEQ,aAAa,CAAC,CAAC;;EAEnC;EACA,MAAMc,mBAAmB,GAAIC,OAAO,IAAK;IACvCtB,iBAAiB,CAACsB,OAAO,CAAC;EAC5B,CAAC;;EAED;EACA,MAAMC,gBAAgB,GAAG,MAAAA,CAAA,KAAY;IACnC,IAAI;MACF,MAAMb,QAAQ,GAAG,MAAMC,KAAK,CAAC,qCAAqC,EAAE;QAClEa,MAAM,EAAE,MAAM;QACdZ,OAAO,EAAE;UACP,cAAc,EAAE,kBAAkB;UAClC,GAAGL,aAAa,CAAC;QACnB,CAAC;QACDkB,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;UACnBC,KAAK,EAAE;QACT,CAAC;MACH,CAAC,CAAC;MAEF,IAAIlB,QAAQ,CAACG,EAAE,EAAE;QACf,MAAMgB,UAAU,GAAG,MAAMnB,QAAQ,CAACK,IAAI,CAAC,CAAC;QACxCjB,WAAW,CAAC,CAAC+B,UAAU,EAAE,GAAGhC,QAAQ,CAAC,CAAC;QACtCG,iBAAiB,CAAC6B,UAAU,CAAC;QAC7B3B,WAAW,CAAC,EAAE,CAAC;MACjB;IACF,CAAC,CAAC,OAAOe,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;IACrD;EACF,CAAC;;EAED;EACA,MAAMa,mBAAmB,GAAG,MAAOC,SAAS,IAAK;IAC/C,IAAI;MACF,MAAMrB,QAAQ,GAAG,MAAMC,KAAK,CAAC,uCAAuCoB,SAAS,EAAE,EAAE;QAC/EP,MAAM,EAAE,QAAQ;QAChBZ,OAAO,EAAEL,aAAa,CAAC;MACzB,CAAC,CAAC;MAEF,IAAIG,QAAQ,CAACG,EAAE,EAAE;QACf;QACA,MAAMmB,eAAe,GAAGnC,QAAQ,CAACoC,MAAM,CAACX,OAAO,IAAIA,OAAO,CAACF,EAAE,KAAKW,SAAS,CAAC;QAC5EjC,WAAW,CAACkC,eAAe,CAAC;;QAE5B;QACA,IAAIjC,cAAc,IAAIA,cAAc,CAACqB,EAAE,KAAKW,SAAS,EAAE;UACrD/B,iBAAiB,CAACgC,eAAe,CAAChB,MAAM,GAAG,CAAC,GAAGgB,eAAe,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;UACzE9B,WAAW,CAAC,EAAE,CAAC;QACjB;MACF;IACF,CAAC,CAAC,OAAOe,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;IACjD;EACF,CAAC;;EAED;EACA,MAAMiB,iBAAiB,GAAG,MAAOC,OAAO,IAAK;IAC3C,IAAI,CAACA,OAAO,CAACC,IAAI,CAAC,CAAC,EAAE;IAErBhC,YAAY,CAAC,IAAI,CAAC;;IAElB;IACA,MAAMiC,WAAW,GAAG;MAClBjB,EAAE,EAAE,QAAQkB,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE;MACxBC,OAAO,EAAEL,OAAO;MAChBM,IAAI,EAAE,MAAM;MACZC,UAAU,EAAE,IAAIJ,IAAI,CAAC,CAAC,CAACK,WAAW,CAAC;IACrC,CAAC;;IAED;IACAzC,WAAW,CAAC0C,YAAY,IAAI,CAAC,GAAGA,YAAY,EAAEP,WAAW,CAAC,CAAC;IAE3D,IAAI;MACF;MACA,MAAMQ,WAAW,GAAG;QAClBV,OAAO,EAAEA,OAAO;QAChBW,UAAU,EAAE/C,cAAc,aAAdA,cAAc,uBAAdA,cAAc,CAAEqB;MAC9B,CAAC;;MAED;MACA,MAAMV,QAAQ,GAAG,MAAMC,KAAK,CAAC,mCAAmC,EAAE;QAChEa,MAAM,EAAE,MAAM;QACdZ,OAAO,EAAE;UACP,cAAc,EAAE,kBAAkB;UAClC,GAAGL,aAAa,CAAC;QACnB,CAAC;QACDkB,IAAI,EAAEC,IAAI,CAACC,SAAS,CAACkB,WAAW;MAClC,CAAC,CAAC;MAEF,IAAI,CAACnC,QAAQ,CAACG,EAAE,EAAE;QAChB,MAAMkC,SAAS,GAAG,MAAMrC,QAAQ,CAACK,IAAI,CAAC,CAAC;QACvC,MAAM,IAAIiC,KAAK,CAACD,SAAS,CAACE,MAAM,IAAI,wBAAwB,CAAC;MAC/D;;MAEA;MACA,MAAMC,MAAM,GAAGxC,QAAQ,CAACe,IAAI,CAAC0B,SAAS,CAAC,CAAC;MACxC,MAAMC,OAAO,GAAG,IAAIC,WAAW,CAAC,CAAC;;MAEjC;MACA,MAAMC,oBAAoB,GAAG;QAC3BlC,EAAE,EAAE,kBAAkBkB,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE;QAClCC,OAAO,EAAE,EAAE;QACXC,IAAI,EAAE,WAAW;QACjBC,UAAU,EAAE,IAAIJ,IAAI,CAAC,CAAC,CAACK,WAAW,CAAC;MACrC,CAAC;MAEDrC,mBAAmB,CAACgD,oBAAoB,CAAC;MAEzC,IAAIvB,SAAS,GAAG,IAAI;MACpB,IAAIwB,SAAS,GAAG,IAAI;;MAEpB;MACA,OAAO,IAAI,EAAE;QACX,MAAM;UAAEC,IAAI;UAAEC;QAAM,CAAC,GAAG,MAAMP,MAAM,CAACQ,IAAI,CAAC,CAAC;QAE3C,IAAIF,IAAI,EAAE;UACR;QACF;;QAEA;QACA,MAAMG,KAAK,GAAGP,OAAO,CAACQ,MAAM,CAACH,KAAK,EAAE;UAAEI,MAAM,EAAE;QAAK,CAAC,CAAC;QACrD,MAAMC,KAAK,GAAGH,KAAK,CAACI,KAAK,CAAC,IAAI,CAAC,CAAC9B,MAAM,CAAC+B,IAAI,IAAIA,IAAI,CAAC5B,IAAI,CAAC,CAAC,CAAC;QAE3D,KAAK,MAAM4B,IAAI,IAAIF,KAAK,EAAE;UACxB,IAAI;YACF,MAAMhD,IAAI,GAAGY,IAAI,CAACuC,KAAK,CAACD,IAAI,CAAC;YAE7B,IAAIlD,IAAI,CAACoD,IAAI,KAAK,YAAY,EAAE;cAC9BnC,SAAS,GAAGjB,IAAI,CAACgC,UAAU;;cAE3B;cACA,IAAI,CAAC/C,cAAc,EAAE;gBACnB,MAAMoE,eAAe,GAAG,MAAMxD,KAAK,CAAC,uCAAuCoB,SAAS,EAAE,EAAE;kBACtFnB,OAAO,EAAEL,aAAa,CAAC;gBACzB,CAAC,CAAC;gBAEF,IAAI4D,eAAe,CAACtD,EAAE,EAAE;kBACtB,MAAMuD,WAAW,GAAG,MAAMD,eAAe,CAACpD,IAAI,CAAC,CAAC;kBAChDf,iBAAiB,CAACoE,WAAW,CAAC;;kBAE9B;kBACA3D,aAAa,CAAC,CAAC;gBACjB;cACF;YACF,CAAC,MAAM,IAAIK,IAAI,CAACoD,IAAI,KAAK,SAAS,EAAE;cAClC;cACA5D,mBAAmB,CAAC+D,IAAI,KAAK;gBAC3B,GAAGA,IAAI;gBACP7B,OAAO,EAAE6B,IAAI,CAAC7B,OAAO,GAAG1B,IAAI,CAAC0B;cAC/B,CAAC,CAAC,CAAC;YACL,CAAC,MAAM,IAAI1B,IAAI,CAACoD,IAAI,KAAK,YAAY,EAAE;cACrCX,SAAS,GAAGzC,IAAI,CAACwD,UAAU;YAC7B,CAAC,MAAM,IAAIxD,IAAI,CAACoD,IAAI,KAAK,OAAO,EAAE;cAChC,MAAM,IAAIlB,KAAK,CAAClC,IAAI,CAACG,KAAK,CAAC;YAC7B;UACF,CAAC,CAAC,OAAOsD,CAAC,EAAE;YACVrD,OAAO,CAACD,KAAK,CAAC,6BAA6B,EAAEsD,CAAC,CAAC;UACjD;QACF;MACF;;MAEA;MACA,IAAIhB,SAAS,EAAE;QACb;QACArD,WAAW,CAAC0C,YAAY,IAAI,CAC1B,GAAGA,YAAY,CAACX,MAAM,CAACuC,CAAC,IAAIA,CAAC,CAACpD,EAAE,KAAKkC,oBAAoB,CAAClC,EAAE,CAAC,EAC7D;UACE,GAAGkC,oBAAoB;UACvBlC,EAAE,EAAEmC;QACN,CAAC,CACF,CAAC;MACJ;;MAEA;MACAjD,mBAAmB,CAAC,IAAI,CAAC;;MAEzB;MACA,IAAIP,cAAc,EAAE;QAClBoB,aAAa,CAACpB,cAAc,CAACqB,EAAE,CAAC;MAClC;IACF,CAAC,CAAC,OAAOH,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;MAC9C;MACAwD,KAAK,CAAC,UAAUxD,KAAK,CAACkB,OAAO,EAAE,CAAC;IAClC,CAAC,SAAS;MACR/B,YAAY,CAAC,KAAK,CAAC;IACrB;EACF,CAAC;EAED,oBACEV,OAAA;IAAKgF,SAAS,EAAC,aAAa;IAAAC,QAAA,gBAC1BjF,OAAA,CAACN,OAAO;MACNS,QAAQ,EAAEA,QAAS;MACnBE,cAAc,EAAEA,cAAe;MAC/B6E,eAAe,EAAEvD,mBAAoB;MACrCwD,YAAY,EAAEtD,gBAAiB;MAC/BuD,eAAe,EAAEhD,mBAAoB;MACrC3B,SAAS,EAAEA;IAAU;MAAA4E,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACtB,CAAC,eACFxF,OAAA;MAAKgF,SAAS,EAAC,WAAW;MAAAC,QAAA,gBACxBjF,OAAA,CAACL,UAAU;QACTU,cAAc,EAAEA;MAAe;QAAAgF,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAChC,CAAC,eACFxF,OAAA,CAACJ,UAAU;QACTW,QAAQ,EAAEA,QAAS;QACnBI,gBAAgB,EAAEA,gBAAiB;QACnCN,cAAc,EAAEA,cAAe;QAC/BI,SAAS,EAAEA;MAAU;QAAA4E,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OACtB,CAAC,eACFxF,OAAA,CAACH,YAAY;QAAC4F,aAAa,EAAEjD;MAAkB;QAAA6C,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAE,CAAC;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAC/C,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACH,CAAC;AAEV,CAAC;AAACtF,EAAA,CAnRID,UAAU;EAAA,QAOYH,OAAO;AAAA;AAAA4F,EAAA,GAP7BzF,UAAU;AAqRhB,eAAeA,UAAU;AAAC,IAAAyF,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}