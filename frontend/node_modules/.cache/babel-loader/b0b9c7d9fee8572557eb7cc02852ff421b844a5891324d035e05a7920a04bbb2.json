{"ast":null,"code":"var _jsxFileName = \"/Users/surajpurohit/Desktop/chat-app/frontend/src/components/chat/ChatLayout.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport Sidebar from './Sidebar';\nimport ChatHeader from './ChatHeader';\nimport ChatWindow from './ChatWindow';\nimport MessageInput from './MessageInput';\nimport { useAuth } from '../../context/AuthContext';\nimport './Chat.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ChatLayout = () => {\n  _s();\n  const [sessions, setSessions] = useState([]);\n  const [currentSession, setCurrentSession] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [streamingMessage, setStreamingMessage] = useState(null);\n  const {\n    getAuthHeader\n  } = useAuth();\n  const eventSourceRef = useRef(null);\n\n  // Fetch chat sessions\n  useEffect(() => {\n    const fetchSessions = async () => {\n      setIsLoading(true);\n      try {\n        const response = await fetch('http://localhost:8000/chat/sessions', {\n          headers: getAuthHeader()\n        });\n        if (response.ok) {\n          const data = await response.json();\n          setSessions(data);\n\n          // If there are sessions and no current session is selected, select the first one\n          if (data.length > 0 && !currentSession) {\n            setCurrentSession(data[0]);\n          }\n        }\n      } catch (error) {\n        console.error('Error fetching sessions:', error);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n    fetchSessions();\n  }, [getAuthHeader, currentSession]);\n\n  // Fetch messages for the current session\n  useEffect(() => {\n    const fetchMessages = async () => {\n      if (!currentSession) return;\n      setIsLoading(true);\n      try {\n        const response = await fetch(`http://localhost:8000/chat/sessions/${currentSession.id}`, {\n          headers: getAuthHeader()\n        });\n        if (response.ok) {\n          const data = await response.json();\n          setMessages(data.messages || []);\n        }\n      } catch (error) {\n        console.error('Error fetching messages:', error);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n    fetchMessages();\n  }, [currentSession, getAuthHeader]);\n\n  // Handle session selection\n  const handleSessionSelect = session => {\n    setCurrentSession(session);\n  };\n\n  // Handle new session creation\n  const handleNewSession = async () => {\n    try {\n      const response = await fetch('http://localhost:8000/chat/sessions', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...getAuthHeader()\n        },\n        body: JSON.stringify({\n          title: 'New Chat'\n        })\n      });\n      if (response.ok) {\n        const newSession = await response.json();\n        setSessions([newSession, ...sessions]);\n        setCurrentSession(newSession);\n        setMessages([]);\n      }\n    } catch (error) {\n      console.error('Error creating new session:', error);\n    }\n  };\n\n  // Handle session deletion\n  const handleDeleteSession = async sessionId => {\n    try {\n      const response = await fetch(`http://localhost:8000/chat/sessions/${sessionId}`, {\n        method: 'DELETE',\n        headers: getAuthHeader()\n      });\n      if (response.ok) {\n        // Remove the session from the list\n        const updatedSessions = sessions.filter(session => session.id !== sessionId);\n        setSessions(updatedSessions);\n\n        // If the current session was deleted, select another one or set to null\n        if (currentSession && currentSession.id === sessionId) {\n          setCurrentSession(updatedSessions.length > 0 ? updatedSessions[0] : null);\n          setMessages([]);\n        }\n      }\n    } catch (error) {\n      console.error('Error deleting session:', error);\n    }\n  };\n\n  // Handle sending a message\n  const handleSendMessage = async content => {\n    if (!content.trim()) return;\n\n    // Add user message to the UI immediately\n    const userMessage = {\n      id: `temp-${Date.now()}`,\n      content,\n      role: 'user',\n      created_at: new Date().toISOString()\n    };\n    setMessages(prev => [...prev, userMessage]);\n\n    // Initialize streaming message\n    setStreamingMessage({\n      id: `streaming-${Date.now()}`,\n      content: '',\n      role: 'assistant',\n      created_at: new Date().toISOString()\n    });\n\n    // Close any existing event source\n    if (eventSourceRef.current) {\n      eventSourceRef.current.close();\n    }\n    try {\n      // Start streaming response\n      const response = await fetch('http://localhost:8000/chat/stream', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...getAuthHeader()\n        },\n        body: JSON.stringify({\n          message: content,\n          session_id: currentSession ? currentSession.id : null\n        })\n      });\n      if (!response.ok) {\n        throw new Error('Failed to send message');\n      }\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n      let sessionId = null;\n      let messageId = null;\n\n      // Process the stream\n      while (true) {\n        const {\n          done,\n          value\n        } = await reader.read();\n        if (done) {\n          break;\n        }\n        const chunk = decoder.decode(value);\n        const lines = chunk.split('\\n').filter(line => line.trim());\n        for (const line of lines) {\n          try {\n            const data = JSON.parse(line);\n            if (data.type === 'session_id') {\n              sessionId = data.session_id;\n\n              // If this is a new session, update the current session\n              if (!currentSession) {\n                // Fetch the new session details\n                const sessionResponse = await fetch(`http://localhost:8000/chat/sessions/${sessionId}`, {\n                  headers: getAuthHeader()\n                });\n                if (sessionResponse.ok) {\n                  const sessionData = await sessionResponse.json();\n                  setCurrentSession(sessionData);\n                  setSessions(prev => [sessionData, ...prev]);\n                }\n              }\n            } else if (data.type === 'content') {\n              // Update the streaming message content\n              setStreamingMessage(prev => ({\n                ...prev,\n                content: prev.content + data.content\n              }));\n            } else if (data.type === 'message_id') {\n              messageId = data.message_id;\n            }\n          } catch (e) {\n            console.error('Error parsing stream chunk:', e);\n          }\n        }\n      }\n\n      // When streaming is complete, replace the streaming message with the final message\n      if (messageId) {\n        setStreamingMessage(null);\n\n        // Fetch the complete message to ensure we have the correct content\n        const messageResponse = await fetch(`http://localhost:8000/chat/sessions/${sessionId}`, {\n          headers: getAuthHeader()\n        });\n        if (messageResponse.ok) {\n          const sessionData = await messageResponse.json();\n          setMessages(sessionData.messages || []);\n        }\n      }\n    } catch (error) {\n      console.error('Error sending message:', error);\n\n      // Add an error message\n      setStreamingMessage(null);\n      setMessages(prev => [...prev, {\n        id: `error-${Date.now()}`,\n        content: 'Error: Failed to get a response. Please try again.',\n        role: 'assistant',\n        created_at: new Date().toISOString()\n      }]);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"chat-layout\",\n    children: [/*#__PURE__*/_jsxDEV(Sidebar, {\n      sessions: sessions,\n      currentSession: currentSession,\n      onSessionSelect: handleSessionSelect,\n      onNewSession: handleNewSession,\n      onDeleteSession: handleDeleteSession,\n      isLoading: isLoading\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 256,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"chat-main\",\n      children: [/*#__PURE__*/_jsxDEV(ChatHeader, {\n        currentSession: currentSession\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 265,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(ChatWindow, {\n        messages: messages,\n        streamingMessage: streamingMessage,\n        currentSession: currentSession,\n        isLoading: isLoading\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 268,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(MessageInput, {\n        onSendMessage: handleSendMessage\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 274,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 264,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 255,\n    columnNumber: 5\n  }, this);\n};\n_s(ChatLayout, \"XLrtFdFl/nkK8A2pzNnCaru0rCg=\", false, function () {\n  return [useAuth];\n});\n_c = ChatLayout;\nexport default ChatLayout;\nvar _c;\n$RefreshReg$(_c, \"ChatLayout\");","map":{"version":3,"names":["React","useState","useEffect","useRef","Sidebar","ChatHeader","ChatWindow","MessageInput","useAuth","jsxDEV","_jsxDEV","ChatLayout","_s","sessions","setSessions","currentSession","setCurrentSession","messages","setMessages","isLoading","setIsLoading","streamingMessage","setStreamingMessage","getAuthHeader","eventSourceRef","fetchSessions","response","fetch","headers","ok","data","json","length","error","console","fetchMessages","id","handleSessionSelect","session","handleNewSession","method","body","JSON","stringify","title","newSession","handleDeleteSession","sessionId","updatedSessions","filter","handleSendMessage","content","trim","userMessage","Date","now","role","created_at","toISOString","prev","current","close","message","session_id","Error","reader","getReader","decoder","TextDecoder","messageId","done","value","read","chunk","decode","lines","split","line","parse","type","sessionResponse","sessionData","message_id","e","messageResponse","className","children","onSessionSelect","onNewSession","onDeleteSession","fileName","_jsxFileName","lineNumber","columnNumber","onSendMessage","_c","$RefreshReg$"],"sources":["/Users/surajpurohit/Desktop/chat-app/frontend/src/components/chat/ChatLayout.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport Sidebar from './Sidebar';\nimport ChatHeader from './ChatHeader';\nimport ChatWindow from './ChatWindow';\nimport MessageInput from './MessageInput';\nimport { useAuth } from '../../context/AuthContext';\nimport './Chat.css';\n\nconst ChatLayout = () => {\n  const [sessions, setSessions] = useState([]);\n  const [currentSession, setCurrentSession] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [streamingMessage, setStreamingMessage] = useState(null);\n  \n  const { getAuthHeader } = useAuth();\n  const eventSourceRef = useRef(null);\n\n  // Fetch chat sessions\n  useEffect(() => {\n    const fetchSessions = async () => {\n      setIsLoading(true);\n      try {\n        const response = await fetch('http://localhost:8000/chat/sessions', {\n          headers: getAuthHeader()\n        });\n        \n        if (response.ok) {\n          const data = await response.json();\n          setSessions(data);\n          \n          // If there are sessions and no current session is selected, select the first one\n          if (data.length > 0 && !currentSession) {\n            setCurrentSession(data[0]);\n          }\n        }\n      } catch (error) {\n        console.error('Error fetching sessions:', error);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    fetchSessions();\n  }, [getAuthHeader, currentSession]);\n\n  // Fetch messages for the current session\n  useEffect(() => {\n    const fetchMessages = async () => {\n      if (!currentSession) return;\n      \n      setIsLoading(true);\n      try {\n        const response = await fetch(`http://localhost:8000/chat/sessions/${currentSession.id}`, {\n          headers: getAuthHeader()\n        });\n        \n        if (response.ok) {\n          const data = await response.json();\n          setMessages(data.messages || []);\n        }\n      } catch (error) {\n        console.error('Error fetching messages:', error);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    fetchMessages();\n  }, [currentSession, getAuthHeader]);\n\n  // Handle session selection\n  const handleSessionSelect = (session) => {\n    setCurrentSession(session);\n  };\n\n  // Handle new session creation\n  const handleNewSession = async () => {\n    try {\n      const response = await fetch('http://localhost:8000/chat/sessions', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...getAuthHeader()\n        },\n        body: JSON.stringify({\n          title: 'New Chat'\n        })\n      });\n      \n      if (response.ok) {\n        const newSession = await response.json();\n        setSessions([newSession, ...sessions]);\n        setCurrentSession(newSession);\n        setMessages([]);\n      }\n    } catch (error) {\n      console.error('Error creating new session:', error);\n    }\n  };\n\n  // Handle session deletion\n  const handleDeleteSession = async (sessionId) => {\n    try {\n      const response = await fetch(`http://localhost:8000/chat/sessions/${sessionId}`, {\n        method: 'DELETE',\n        headers: getAuthHeader()\n      });\n      \n      if (response.ok) {\n        // Remove the session from the list\n        const updatedSessions = sessions.filter(session => session.id !== sessionId);\n        setSessions(updatedSessions);\n        \n        // If the current session was deleted, select another one or set to null\n        if (currentSession && currentSession.id === sessionId) {\n          setCurrentSession(updatedSessions.length > 0 ? updatedSessions[0] : null);\n          setMessages([]);\n        }\n      }\n    } catch (error) {\n      console.error('Error deleting session:', error);\n    }\n  };\n\n  // Handle sending a message\n  const handleSendMessage = async (content) => {\n    if (!content.trim()) return;\n    \n    // Add user message to the UI immediately\n    const userMessage = {\n      id: `temp-${Date.now()}`,\n      content,\n      role: 'user',\n      created_at: new Date().toISOString()\n    };\n    \n    setMessages(prev => [...prev, userMessage]);\n    \n    // Initialize streaming message\n    setStreamingMessage({\n      id: `streaming-${Date.now()}`,\n      content: '',\n      role: 'assistant',\n      created_at: new Date().toISOString()\n    });\n    \n    // Close any existing event source\n    if (eventSourceRef.current) {\n      eventSourceRef.current.close();\n    }\n    \n    try {\n      // Start streaming response\n      const response = await fetch('http://localhost:8000/chat/stream', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...getAuthHeader()\n        },\n        body: JSON.stringify({\n          message: content,\n          session_id: currentSession ? currentSession.id : null\n        })\n      });\n      \n      if (!response.ok) {\n        throw new Error('Failed to send message');\n      }\n      \n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n      \n      let sessionId = null;\n      let messageId = null;\n      \n      // Process the stream\n      while (true) {\n        const { done, value } = await reader.read();\n        \n        if (done) {\n          break;\n        }\n        \n        const chunk = decoder.decode(value);\n        const lines = chunk.split('\\n').filter(line => line.trim());\n        \n        for (const line of lines) {\n          try {\n            const data = JSON.parse(line);\n            \n            if (data.type === 'session_id') {\n              sessionId = data.session_id;\n              \n              // If this is a new session, update the current session\n              if (!currentSession) {\n                // Fetch the new session details\n                const sessionResponse = await fetch(`http://localhost:8000/chat/sessions/${sessionId}`, {\n                  headers: getAuthHeader()\n                });\n                \n                if (sessionResponse.ok) {\n                  const sessionData = await sessionResponse.json();\n                  setCurrentSession(sessionData);\n                  setSessions(prev => [sessionData, ...prev]);\n                }\n              }\n            } else if (data.type === 'content') {\n              // Update the streaming message content\n              setStreamingMessage(prev => ({\n                ...prev,\n                content: prev.content + data.content\n              }));\n            } else if (data.type === 'message_id') {\n              messageId = data.message_id;\n            }\n          } catch (e) {\n            console.error('Error parsing stream chunk:', e);\n          }\n        }\n      }\n      \n      // When streaming is complete, replace the streaming message with the final message\n      if (messageId) {\n        setStreamingMessage(null);\n        \n        // Fetch the complete message to ensure we have the correct content\n        const messageResponse = await fetch(`http://localhost:8000/chat/sessions/${sessionId}`, {\n          headers: getAuthHeader()\n        });\n        \n        if (messageResponse.ok) {\n          const sessionData = await messageResponse.json();\n          setMessages(sessionData.messages || []);\n        }\n      }\n    } catch (error) {\n      console.error('Error sending message:', error);\n      \n      // Add an error message\n      setStreamingMessage(null);\n      setMessages(prev => [\n        ...prev,\n        {\n          id: `error-${Date.now()}`,\n          content: 'Error: Failed to get a response. Please try again.',\n          role: 'assistant',\n          created_at: new Date().toISOString()\n        }\n      ]);\n    }\n  };\n\n  return (\n    <div className=\"chat-layout\">\n      <Sidebar \n        sessions={sessions}\n        currentSession={currentSession}\n        onSessionSelect={handleSessionSelect}\n        onNewSession={handleNewSession}\n        onDeleteSession={handleDeleteSession}\n        isLoading={isLoading}\n      />\n      <div className=\"chat-main\">\n        <ChatHeader \n          currentSession={currentSession} \n        />\n        <ChatWindow \n          messages={messages} \n          streamingMessage={streamingMessage}\n          currentSession={currentSession}\n          isLoading={isLoading}\n        />\n        <MessageInput onSendMessage={handleSendMessage} />\n      </div>\n    </div>\n  );\n};\n\nexport default ChatLayout; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}