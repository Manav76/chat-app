{"ast":null,"code":"var _jsxFileName = \"/Users/surajpurohit/Desktop/chat-app/frontend/src/components/chat/ChatLayout.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport Sidebar from './Sidebar';\nimport ChatHeader from './ChatHeader';\nimport ChatWindow from './ChatWindow';\nimport MessageInput from './MessageInput';\nimport { useAuth } from '../../context/AuthContext';\nimport './Chat.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ChatLayout = () => {\n  _s();\n  const [sessions, setSessions] = useState([]);\n  const [currentSession, setCurrentSession] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [streamingMessage, setStreamingMessage] = useState(null);\n  const {\n    getAuthHeader\n  } = useAuth();\n  const eventSourceRef = useRef(null);\n\n  // Fetch chat sessions\n  useEffect(() => {\n    const fetchSessions = async () => {\n      setIsLoading(true);\n      try {\n        const response = await fetch('http://localhost:8000/chat/sessions', {\n          headers: getAuthHeader()\n        });\n        if (response.ok) {\n          const data = await response.json();\n          setSessions(data);\n\n          // If there are sessions and no current session is selected, select the first one\n          if (data.length > 0 && !currentSession) {\n            setCurrentSession(data[0]);\n          }\n        }\n      } catch (error) {\n        console.error('Error fetching sessions:', error);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n    fetchSessions();\n  }, [getAuthHeader, currentSession]);\n\n  // Fetch messages for the current session\n  useEffect(() => {\n    const fetchMessages = async () => {\n      if (!currentSession) return;\n      setIsLoading(true);\n      try {\n        const response = await fetch(`http://localhost:8000/chat/sessions/${currentSession.id}`, {\n          headers: getAuthHeader()\n        });\n        if (response.ok) {\n          const data = await response.json();\n          setMessages(data.messages || []);\n        }\n      } catch (error) {\n        console.error('Error fetching messages:', error);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n    fetchMessages();\n  }, [currentSession, getAuthHeader]);\n\n  // Handle session selection\n  const handleSessionSelect = session => {\n    setCurrentSession(session);\n  };\n\n  // Handle new session creation\n  const handleNewSession = async () => {\n    try {\n      const response = await fetch('http://localhost:8000/chat/sessions', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...getAuthHeader()\n        },\n        body: JSON.stringify({\n          title: 'New Chat'\n        })\n      });\n      if (response.ok) {\n        const newSession = await response.json();\n        setSessions([newSession, ...sessions]);\n        setCurrentSession(newSession);\n        setMessages([]);\n      }\n    } catch (error) {\n      console.error('Error creating new session:', error);\n    }\n  };\n\n  // Handle session deletion\n  const handleDeleteSession = async sessionId => {\n    try {\n      const response = await fetch(`http://localhost:8000/chat/sessions/${sessionId}`, {\n        method: 'DELETE',\n        headers: getAuthHeader()\n      });\n      if (response.ok) {\n        // Remove the session from the list\n        const updatedSessions = sessions.filter(session => session.id !== sessionId);\n        setSessions(updatedSessions);\n\n        // If the current session was deleted, select another one or set to null\n        if (currentSession && currentSession.id === sessionId) {\n          setCurrentSession(updatedSessions.length > 0 ? updatedSessions[0] : null);\n          setMessages([]);\n        }\n      }\n    } catch (error) {\n      console.error('Error deleting session:', error);\n    }\n  };\n\n  // Handle sending a message\n  const handleSendMessage = async content => {\n    if (!content.trim()) return;\n\n    // Add user message to the UI immediately\n    const userMessage = {\n      id: `temp-${Date.now()}`,\n      content,\n      role: 'user',\n      created_at: new Date().toISOString()\n    };\n    setMessages(prev => [...prev, userMessage]);\n\n    // Initialize streaming message\n    const streamingMessageId = `streaming-${Date.now()}`;\n    setStreamingMessage({\n      id: streamingMessageId,\n      content: '',\n      role: 'assistant',\n      created_at: new Date().toISOString()\n    });\n\n    // Close any existing event source\n    if (eventSourceRef.current) {\n      eventSourceRef.current.close();\n    }\n    try {\n      console.log('Starting streaming request...');\n      // Start streaming response\n      const response = await fetch('http://localhost:8000/chat/stream', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...getAuthHeader()\n        },\n        body: JSON.stringify({\n          message: content,\n          session_id: currentSession ? currentSession.id : null\n        })\n      });\n      if (!response.ok) {\n        console.error('Stream response not OK:', response.status);\n        throw new Error('Failed to send message');\n      }\n      console.log('Stream response OK, starting reader...');\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n      let sessionId = null;\n      let messageId = null;\n\n      // Process the stream\n      while (true) {\n        const {\n          done,\n          value\n        } = await reader.read();\n        if (done) {\n          console.log('Stream complete');\n          break;\n        }\n        const chunk = decoder.decode(value);\n        console.log('Received chunk:', chunk);\n        const lines = chunk.split('\\n').filter(line => line.trim());\n        for (const line of lines) {\n          try {\n            const data = JSON.parse(line);\n            console.log('Parsed data:', data);\n            if (data.type === 'session_id') {\n              sessionId = data.session_id;\n              console.log('Received session ID:', sessionId);\n\n              // If this is a new session, update the current session\n              if (!currentSession) {\n                // Fetch the new session details\n                console.log('Fetching new session details...');\n                const sessionResponse = await fetch(`http://localhost:8000/chat/sessions/${sessionId}`, {\n                  headers: getAuthHeader()\n                });\n                if (sessionResponse.ok) {\n                  const sessionData = await sessionResponse.json();\n                  console.log('Session data:', sessionData);\n                  setCurrentSession(sessionData);\n                  setSessions(prev => [sessionData, ...prev]);\n                } else {\n                  console.error('Failed to fetch session details:', sessionResponse.status);\n                }\n              }\n            } else if (data.type === 'content') {\n              // Update streaming message content\n              setStreamingMessage(prev => ({\n                ...prev,\n                content: prev ? prev.content + data.content : data.content\n              }));\n            } else if (data.type === 'message_id') {\n              messageId = data.message_id;\n              console.log('Received message ID:', messageId);\n            } else if (data.type === 'error') {\n              console.error('Stream error:', data.error);\n              throw new Error(data.error);\n            }\n          } catch (e) {\n            console.error('Error parsing stream chunk:', e, line);\n          }\n        }\n      }\n\n      // When streaming is complete, replace the streaming message with the final message\n      if (messageId) {\n        console.log('Updating message with final ID:', messageId);\n        setStreamingMessage(null);\n\n        // Fetch the complete message to ensure we have the correct content\n        const messageResponse = await fetch(`http://localhost:8000/chat/sessions/${sessionId}`, {\n          headers: getAuthHeader()\n        });\n        if (messageResponse.ok) {\n          const sessionData = await messageResponse.json();\n          console.log('Final session data:', sessionData);\n          setMessages(sessionData.messages || []);\n        } else {\n          console.error('Failed to fetch final messages:', messageResponse.status);\n        }\n      }\n    } catch (error) {\n      console.error('Error sending message:', error);\n\n      // Add an error message\n      setStreamingMessage(null);\n      setMessages(prev => [...prev, {\n        id: `error-${Date.now()}`,\n        content: `Error: ${error.message || 'Failed to get a response. Please try again.'}`,\n        role: 'assistant',\n        created_at: new Date().toISOString()\n      }]);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"chat-layout\",\n    children: [/*#__PURE__*/_jsxDEV(Sidebar, {\n      sessions: sessions,\n      currentSession: currentSession,\n      onSessionSelect: handleSessionSelect,\n      onNewSession: handleNewSession,\n      onDeleteSession: handleDeleteSession,\n      isLoading: isLoading\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 276,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"chat-main\",\n      children: [/*#__PURE__*/_jsxDEV(ChatHeader, {\n        currentSession: currentSession\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 285,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(ChatWindow, {\n        messages: messages,\n        streamingMessage: streamingMessage,\n        currentSession: currentSession,\n        isLoading: isLoading\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 288,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(MessageInput, {\n        onSendMessage: handleSendMessage\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 294,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 284,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 275,\n    columnNumber: 5\n  }, this);\n};\n_s(ChatLayout, \"XLrtFdFl/nkK8A2pzNnCaru0rCg=\", false, function () {\n  return [useAuth];\n});\n_c = ChatLayout;\nexport default ChatLayout;\nvar _c;\n$RefreshReg$(_c, \"ChatLayout\");","map":{"version":3,"names":["React","useState","useEffect","useRef","Sidebar","ChatHeader","ChatWindow","MessageInput","useAuth","jsxDEV","_jsxDEV","ChatLayout","_s","sessions","setSessions","currentSession","setCurrentSession","messages","setMessages","isLoading","setIsLoading","streamingMessage","setStreamingMessage","getAuthHeader","eventSourceRef","fetchSessions","response","fetch","headers","ok","data","json","length","error","console","fetchMessages","id","handleSessionSelect","session","handleNewSession","method","body","JSON","stringify","title","newSession","handleDeleteSession","sessionId","updatedSessions","filter","handleSendMessage","content","trim","userMessage","Date","now","role","created_at","toISOString","prev","streamingMessageId","current","close","log","message","session_id","status","Error","reader","getReader","decoder","TextDecoder","messageId","done","value","read","chunk","decode","lines","split","line","parse","type","sessionResponse","sessionData","message_id","e","messageResponse","className","children","onSessionSelect","onNewSession","onDeleteSession","fileName","_jsxFileName","lineNumber","columnNumber","onSendMessage","_c","$RefreshReg$"],"sources":["/Users/surajpurohit/Desktop/chat-app/frontend/src/components/chat/ChatLayout.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport Sidebar from './Sidebar';\nimport ChatHeader from './ChatHeader';\nimport ChatWindow from './ChatWindow';\nimport MessageInput from './MessageInput';\nimport { useAuth } from '../../context/AuthContext';\nimport './Chat.css';\n\nconst ChatLayout = () => {\n  const [sessions, setSessions] = useState([]);\n  const [currentSession, setCurrentSession] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [streamingMessage, setStreamingMessage] = useState(null);\n  \n  const { getAuthHeader } = useAuth();\n  const eventSourceRef = useRef(null);\n\n  // Fetch chat sessions\n  useEffect(() => {\n    const fetchSessions = async () => {\n      setIsLoading(true);\n      try {\n        const response = await fetch('http://localhost:8000/chat/sessions', {\n          headers: getAuthHeader()\n        });\n        \n        if (response.ok) {\n          const data = await response.json();\n          setSessions(data);\n          \n          // If there are sessions and no current session is selected, select the first one\n          if (data.length > 0 && !currentSession) {\n            setCurrentSession(data[0]);\n          }\n        }\n      } catch (error) {\n        console.error('Error fetching sessions:', error);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    fetchSessions();\n  }, [getAuthHeader, currentSession]);\n\n  // Fetch messages for the current session\n  useEffect(() => {\n    const fetchMessages = async () => {\n      if (!currentSession) return;\n      \n      setIsLoading(true);\n      try {\n        const response = await fetch(`http://localhost:8000/chat/sessions/${currentSession.id}`, {\n          headers: getAuthHeader()\n        });\n        \n        if (response.ok) {\n          const data = await response.json();\n          setMessages(data.messages || []);\n        }\n      } catch (error) {\n        console.error('Error fetching messages:', error);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    fetchMessages();\n  }, [currentSession, getAuthHeader]);\n\n  // Handle session selection\n  const handleSessionSelect = (session) => {\n    setCurrentSession(session);\n  };\n\n  // Handle new session creation\n  const handleNewSession = async () => {\n    try {\n      const response = await fetch('http://localhost:8000/chat/sessions', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...getAuthHeader()\n        },\n        body: JSON.stringify({\n          title: 'New Chat'\n        })\n      });\n      \n      if (response.ok) {\n        const newSession = await response.json();\n        setSessions([newSession, ...sessions]);\n        setCurrentSession(newSession);\n        setMessages([]);\n      }\n    } catch (error) {\n      console.error('Error creating new session:', error);\n    }\n  };\n\n  // Handle session deletion\n  const handleDeleteSession = async (sessionId) => {\n    try {\n      const response = await fetch(`http://localhost:8000/chat/sessions/${sessionId}`, {\n        method: 'DELETE',\n        headers: getAuthHeader()\n      });\n      \n      if (response.ok) {\n        // Remove the session from the list\n        const updatedSessions = sessions.filter(session => session.id !== sessionId);\n        setSessions(updatedSessions);\n        \n        // If the current session was deleted, select another one or set to null\n        if (currentSession && currentSession.id === sessionId) {\n          setCurrentSession(updatedSessions.length > 0 ? updatedSessions[0] : null);\n          setMessages([]);\n        }\n      }\n    } catch (error) {\n      console.error('Error deleting session:', error);\n    }\n  };\n\n  // Handle sending a message\n  const handleSendMessage = async (content) => {\n    if (!content.trim()) return;\n    \n    // Add user message to the UI immediately\n    const userMessage = {\n      id: `temp-${Date.now()}`,\n      content,\n      role: 'user',\n      created_at: new Date().toISOString()\n    };\n    \n    setMessages(prev => [...prev, userMessage]);\n    \n    // Initialize streaming message\n    const streamingMessageId = `streaming-${Date.now()}`;\n    setStreamingMessage({\n      id: streamingMessageId,\n      content: '',\n      role: 'assistant',\n      created_at: new Date().toISOString()\n    });\n    \n    // Close any existing event source\n    if (eventSourceRef.current) {\n      eventSourceRef.current.close();\n    }\n    \n    try {\n      console.log('Starting streaming request...');\n      // Start streaming response\n      const response = await fetch('http://localhost:8000/chat/stream', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...getAuthHeader()\n        },\n        body: JSON.stringify({\n          message: content,\n          session_id: currentSession ? currentSession.id : null\n        })\n      });\n      \n      if (!response.ok) {\n        console.error('Stream response not OK:', response.status);\n        throw new Error('Failed to send message');\n      }\n      \n      console.log('Stream response OK, starting reader...');\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n      \n      let sessionId = null;\n      let messageId = null;\n      \n      // Process the stream\n      while (true) {\n        const { done, value } = await reader.read();\n        \n        if (done) {\n          console.log('Stream complete');\n          break;\n        }\n        \n        const chunk = decoder.decode(value);\n        console.log('Received chunk:', chunk);\n        const lines = chunk.split('\\n').filter(line => line.trim());\n        \n        for (const line of lines) {\n          try {\n            const data = JSON.parse(line);\n            console.log('Parsed data:', data);\n            \n            if (data.type === 'session_id') {\n              sessionId = data.session_id;\n              console.log('Received session ID:', sessionId);\n              \n              // If this is a new session, update the current session\n              if (!currentSession) {\n                // Fetch the new session details\n                console.log('Fetching new session details...');\n                const sessionResponse = await fetch(`http://localhost:8000/chat/sessions/${sessionId}`, {\n                  headers: getAuthHeader()\n                });\n                \n                if (sessionResponse.ok) {\n                  const sessionData = await sessionResponse.json();\n                  console.log('Session data:', sessionData);\n                  setCurrentSession(sessionData);\n                  setSessions(prev => [sessionData, ...prev]);\n                } else {\n                  console.error('Failed to fetch session details:', sessionResponse.status);\n                }\n              }\n            } else if (data.type === 'content') {\n              // Update streaming message content\n              setStreamingMessage(prev => ({\n                ...prev,\n                content: prev ? prev.content + data.content : data.content\n              }));\n            } else if (data.type === 'message_id') {\n              messageId = data.message_id;\n              console.log('Received message ID:', messageId);\n            } else if (data.type === 'error') {\n              console.error('Stream error:', data.error);\n              throw new Error(data.error);\n            }\n          } catch (e) {\n            console.error('Error parsing stream chunk:', e, line);\n          }\n        }\n      }\n      \n      // When streaming is complete, replace the streaming message with the final message\n      if (messageId) {\n        console.log('Updating message with final ID:', messageId);\n        setStreamingMessage(null);\n        \n        // Fetch the complete message to ensure we have the correct content\n        const messageResponse = await fetch(`http://localhost:8000/chat/sessions/${sessionId}`, {\n          headers: getAuthHeader()\n        });\n        \n        if (messageResponse.ok) {\n          const sessionData = await messageResponse.json();\n          console.log('Final session data:', sessionData);\n          setMessages(sessionData.messages || []);\n        } else {\n          console.error('Failed to fetch final messages:', messageResponse.status);\n        }\n      }\n    } catch (error) {\n      console.error('Error sending message:', error);\n      \n      // Add an error message\n      setStreamingMessage(null);\n      setMessages(prev => [\n        ...prev,\n        {\n          id: `error-${Date.now()}`,\n          content: `Error: ${error.message || 'Failed to get a response. Please try again.'}`,\n          role: 'assistant',\n          created_at: new Date().toISOString()\n        }\n      ]);\n    }\n  };\n\n  return (\n    <div className=\"chat-layout\">\n      <Sidebar \n        sessions={sessions}\n        currentSession={currentSession}\n        onSessionSelect={handleSessionSelect}\n        onNewSession={handleNewSession}\n        onDeleteSession={handleDeleteSession}\n        isLoading={isLoading}\n      />\n      <div className=\"chat-main\">\n        <ChatHeader \n          currentSession={currentSession} \n        />\n        <ChatWindow \n          messages={messages} \n          streamingMessage={streamingMessage}\n          currentSession={currentSession}\n          isLoading={isLoading}\n        />\n        <MessageInput onSendMessage={handleSendMessage} />\n      </div>\n    </div>\n  );\n};\n\nexport default ChatLayout; "],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,QAAQ,EAAEC,SAAS,EAAEC,MAAM,QAAQ,OAAO;AAC1D,OAAOC,OAAO,MAAM,WAAW;AAC/B,OAAOC,UAAU,MAAM,cAAc;AACrC,OAAOC,UAAU,MAAM,cAAc;AACrC,OAAOC,YAAY,MAAM,gBAAgB;AACzC,SAASC,OAAO,QAAQ,2BAA2B;AACnD,OAAO,YAAY;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEpB,MAAMC,UAAU,GAAGA,CAAA,KAAM;EAAAC,EAAA;EACvB,MAAM,CAACC,QAAQ,EAAEC,WAAW,CAAC,GAAGb,QAAQ,CAAC,EAAE,CAAC;EAC5C,MAAM,CAACc,cAAc,EAAEC,iBAAiB,CAAC,GAAGf,QAAQ,CAAC,IAAI,CAAC;EAC1D,MAAM,CAACgB,QAAQ,EAAEC,WAAW,CAAC,GAAGjB,QAAQ,CAAC,EAAE,CAAC;EAC5C,MAAM,CAACkB,SAAS,EAAEC,YAAY,CAAC,GAAGnB,QAAQ,CAAC,KAAK,CAAC;EACjD,MAAM,CAACoB,gBAAgB,EAAEC,mBAAmB,CAAC,GAAGrB,QAAQ,CAAC,IAAI,CAAC;EAE9D,MAAM;IAAEsB;EAAc,CAAC,GAAGf,OAAO,CAAC,CAAC;EACnC,MAAMgB,cAAc,GAAGrB,MAAM,CAAC,IAAI,CAAC;;EAEnC;EACAD,SAAS,CAAC,MAAM;IACd,MAAMuB,aAAa,GAAG,MAAAA,CAAA,KAAY;MAChCL,YAAY,CAAC,IAAI,CAAC;MAClB,IAAI;QACF,MAAMM,QAAQ,GAAG,MAAMC,KAAK,CAAC,qCAAqC,EAAE;UAClEC,OAAO,EAAEL,aAAa,CAAC;QACzB,CAAC,CAAC;QAEF,IAAIG,QAAQ,CAACG,EAAE,EAAE;UACf,MAAMC,IAAI,GAAG,MAAMJ,QAAQ,CAACK,IAAI,CAAC,CAAC;UAClCjB,WAAW,CAACgB,IAAI,CAAC;;UAEjB;UACA,IAAIA,IAAI,CAACE,MAAM,GAAG,CAAC,IAAI,CAACjB,cAAc,EAAE;YACtCC,iBAAiB,CAACc,IAAI,CAAC,CAAC,CAAC,CAAC;UAC5B;QACF;MACF,CAAC,CAAC,OAAOG,KAAK,EAAE;QACdC,OAAO,CAACD,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;MAClD,CAAC,SAAS;QACRb,YAAY,CAAC,KAAK,CAAC;MACrB;IACF,CAAC;IAEDK,aAAa,CAAC,CAAC;EACjB,CAAC,EAAE,CAACF,aAAa,EAAER,cAAc,CAAC,CAAC;;EAEnC;EACAb,SAAS,CAAC,MAAM;IACd,MAAMiC,aAAa,GAAG,MAAAA,CAAA,KAAY;MAChC,IAAI,CAACpB,cAAc,EAAE;MAErBK,YAAY,CAAC,IAAI,CAAC;MAClB,IAAI;QACF,MAAMM,QAAQ,GAAG,MAAMC,KAAK,CAAC,uCAAuCZ,cAAc,CAACqB,EAAE,EAAE,EAAE;UACvFR,OAAO,EAAEL,aAAa,CAAC;QACzB,CAAC,CAAC;QAEF,IAAIG,QAAQ,CAACG,EAAE,EAAE;UACf,MAAMC,IAAI,GAAG,MAAMJ,QAAQ,CAACK,IAAI,CAAC,CAAC;UAClCb,WAAW,CAACY,IAAI,CAACb,QAAQ,IAAI,EAAE,CAAC;QAClC;MACF,CAAC,CAAC,OAAOgB,KAAK,EAAE;QACdC,OAAO,CAACD,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;MAClD,CAAC,SAAS;QACRb,YAAY,CAAC,KAAK,CAAC;MACrB;IACF,CAAC;IAEDe,aAAa,CAAC,CAAC;EACjB,CAAC,EAAE,CAACpB,cAAc,EAAEQ,aAAa,CAAC,CAAC;;EAEnC;EACA,MAAMc,mBAAmB,GAAIC,OAAO,IAAK;IACvCtB,iBAAiB,CAACsB,OAAO,CAAC;EAC5B,CAAC;;EAED;EACA,MAAMC,gBAAgB,GAAG,MAAAA,CAAA,KAAY;IACnC,IAAI;MACF,MAAMb,QAAQ,GAAG,MAAMC,KAAK,CAAC,qCAAqC,EAAE;QAClEa,MAAM,EAAE,MAAM;QACdZ,OAAO,EAAE;UACP,cAAc,EAAE,kBAAkB;UAClC,GAAGL,aAAa,CAAC;QACnB,CAAC;QACDkB,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;UACnBC,KAAK,EAAE;QACT,CAAC;MACH,CAAC,CAAC;MAEF,IAAIlB,QAAQ,CAACG,EAAE,EAAE;QACf,MAAMgB,UAAU,GAAG,MAAMnB,QAAQ,CAACK,IAAI,CAAC,CAAC;QACxCjB,WAAW,CAAC,CAAC+B,UAAU,EAAE,GAAGhC,QAAQ,CAAC,CAAC;QACtCG,iBAAiB,CAAC6B,UAAU,CAAC;QAC7B3B,WAAW,CAAC,EAAE,CAAC;MACjB;IACF,CAAC,CAAC,OAAOe,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;IACrD;EACF,CAAC;;EAED;EACA,MAAMa,mBAAmB,GAAG,MAAOC,SAAS,IAAK;IAC/C,IAAI;MACF,MAAMrB,QAAQ,GAAG,MAAMC,KAAK,CAAC,uCAAuCoB,SAAS,EAAE,EAAE;QAC/EP,MAAM,EAAE,QAAQ;QAChBZ,OAAO,EAAEL,aAAa,CAAC;MACzB,CAAC,CAAC;MAEF,IAAIG,QAAQ,CAACG,EAAE,EAAE;QACf;QACA,MAAMmB,eAAe,GAAGnC,QAAQ,CAACoC,MAAM,CAACX,OAAO,IAAIA,OAAO,CAACF,EAAE,KAAKW,SAAS,CAAC;QAC5EjC,WAAW,CAACkC,eAAe,CAAC;;QAE5B;QACA,IAAIjC,cAAc,IAAIA,cAAc,CAACqB,EAAE,KAAKW,SAAS,EAAE;UACrD/B,iBAAiB,CAACgC,eAAe,CAAChB,MAAM,GAAG,CAAC,GAAGgB,eAAe,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;UACzE9B,WAAW,CAAC,EAAE,CAAC;QACjB;MACF;IACF,CAAC,CAAC,OAAOe,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;IACjD;EACF,CAAC;;EAED;EACA,MAAMiB,iBAAiB,GAAG,MAAOC,OAAO,IAAK;IAC3C,IAAI,CAACA,OAAO,CAACC,IAAI,CAAC,CAAC,EAAE;;IAErB;IACA,MAAMC,WAAW,GAAG;MAClBjB,EAAE,EAAE,QAAQkB,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE;MACxBJ,OAAO;MACPK,IAAI,EAAE,MAAM;MACZC,UAAU,EAAE,IAAIH,IAAI,CAAC,CAAC,CAACI,WAAW,CAAC;IACrC,CAAC;IAEDxC,WAAW,CAACyC,IAAI,IAAI,CAAC,GAAGA,IAAI,EAAEN,WAAW,CAAC,CAAC;;IAE3C;IACA,MAAMO,kBAAkB,GAAG,aAAaN,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE;IACpDjC,mBAAmB,CAAC;MAClBc,EAAE,EAAEwB,kBAAkB;MACtBT,OAAO,EAAE,EAAE;MACXK,IAAI,EAAE,WAAW;MACjBC,UAAU,EAAE,IAAIH,IAAI,CAAC,CAAC,CAACI,WAAW,CAAC;IACrC,CAAC,CAAC;;IAEF;IACA,IAAIlC,cAAc,CAACqC,OAAO,EAAE;MAC1BrC,cAAc,CAACqC,OAAO,CAACC,KAAK,CAAC,CAAC;IAChC;IAEA,IAAI;MACF5B,OAAO,CAAC6B,GAAG,CAAC,+BAA+B,CAAC;MAC5C;MACA,MAAMrC,QAAQ,GAAG,MAAMC,KAAK,CAAC,mCAAmC,EAAE;QAChEa,MAAM,EAAE,MAAM;QACdZ,OAAO,EAAE;UACP,cAAc,EAAE,kBAAkB;UAClC,GAAGL,aAAa,CAAC;QACnB,CAAC;QACDkB,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;UACnBqB,OAAO,EAAEb,OAAO;UAChBc,UAAU,EAAElD,cAAc,GAAGA,cAAc,CAACqB,EAAE,GAAG;QACnD,CAAC;MACH,CAAC,CAAC;MAEF,IAAI,CAACV,QAAQ,CAACG,EAAE,EAAE;QAChBK,OAAO,CAACD,KAAK,CAAC,yBAAyB,EAAEP,QAAQ,CAACwC,MAAM,CAAC;QACzD,MAAM,IAAIC,KAAK,CAAC,wBAAwB,CAAC;MAC3C;MAEAjC,OAAO,CAAC6B,GAAG,CAAC,wCAAwC,CAAC;MACrD,MAAMK,MAAM,GAAG1C,QAAQ,CAACe,IAAI,CAAC4B,SAAS,CAAC,CAAC;MACxC,MAAMC,OAAO,GAAG,IAAIC,WAAW,CAAC,CAAC;MAEjC,IAAIxB,SAAS,GAAG,IAAI;MACpB,IAAIyB,SAAS,GAAG,IAAI;;MAEpB;MACA,OAAO,IAAI,EAAE;QACX,MAAM;UAAEC,IAAI;UAAEC;QAAM,CAAC,GAAG,MAAMN,MAAM,CAACO,IAAI,CAAC,CAAC;QAE3C,IAAIF,IAAI,EAAE;UACRvC,OAAO,CAAC6B,GAAG,CAAC,iBAAiB,CAAC;UAC9B;QACF;QAEA,MAAMa,KAAK,GAAGN,OAAO,CAACO,MAAM,CAACH,KAAK,CAAC;QACnCxC,OAAO,CAAC6B,GAAG,CAAC,iBAAiB,EAAEa,KAAK,CAAC;QACrC,MAAME,KAAK,GAAGF,KAAK,CAACG,KAAK,CAAC,IAAI,CAAC,CAAC9B,MAAM,CAAC+B,IAAI,IAAIA,IAAI,CAAC5B,IAAI,CAAC,CAAC,CAAC;QAE3D,KAAK,MAAM4B,IAAI,IAAIF,KAAK,EAAE;UACxB,IAAI;YACF,MAAMhD,IAAI,GAAGY,IAAI,CAACuC,KAAK,CAACD,IAAI,CAAC;YAC7B9C,OAAO,CAAC6B,GAAG,CAAC,cAAc,EAAEjC,IAAI,CAAC;YAEjC,IAAIA,IAAI,CAACoD,IAAI,KAAK,YAAY,EAAE;cAC9BnC,SAAS,GAAGjB,IAAI,CAACmC,UAAU;cAC3B/B,OAAO,CAAC6B,GAAG,CAAC,sBAAsB,EAAEhB,SAAS,CAAC;;cAE9C;cACA,IAAI,CAAChC,cAAc,EAAE;gBACnB;gBACAmB,OAAO,CAAC6B,GAAG,CAAC,iCAAiC,CAAC;gBAC9C,MAAMoB,eAAe,GAAG,MAAMxD,KAAK,CAAC,uCAAuCoB,SAAS,EAAE,EAAE;kBACtFnB,OAAO,EAAEL,aAAa,CAAC;gBACzB,CAAC,CAAC;gBAEF,IAAI4D,eAAe,CAACtD,EAAE,EAAE;kBACtB,MAAMuD,WAAW,GAAG,MAAMD,eAAe,CAACpD,IAAI,CAAC,CAAC;kBAChDG,OAAO,CAAC6B,GAAG,CAAC,eAAe,EAAEqB,WAAW,CAAC;kBACzCpE,iBAAiB,CAACoE,WAAW,CAAC;kBAC9BtE,WAAW,CAAC6C,IAAI,IAAI,CAACyB,WAAW,EAAE,GAAGzB,IAAI,CAAC,CAAC;gBAC7C,CAAC,MAAM;kBACLzB,OAAO,CAACD,KAAK,CAAC,kCAAkC,EAAEkD,eAAe,CAACjB,MAAM,CAAC;gBAC3E;cACF;YACF,CAAC,MAAM,IAAIpC,IAAI,CAACoD,IAAI,KAAK,SAAS,EAAE;cAClC;cACA5D,mBAAmB,CAACqC,IAAI,KAAK;gBAC3B,GAAGA,IAAI;gBACPR,OAAO,EAAEQ,IAAI,GAAGA,IAAI,CAACR,OAAO,GAAGrB,IAAI,CAACqB,OAAO,GAAGrB,IAAI,CAACqB;cACrD,CAAC,CAAC,CAAC;YACL,CAAC,MAAM,IAAIrB,IAAI,CAACoD,IAAI,KAAK,YAAY,EAAE;cACrCV,SAAS,GAAG1C,IAAI,CAACuD,UAAU;cAC3BnD,OAAO,CAAC6B,GAAG,CAAC,sBAAsB,EAAES,SAAS,CAAC;YAChD,CAAC,MAAM,IAAI1C,IAAI,CAACoD,IAAI,KAAK,OAAO,EAAE;cAChChD,OAAO,CAACD,KAAK,CAAC,eAAe,EAAEH,IAAI,CAACG,KAAK,CAAC;cAC1C,MAAM,IAAIkC,KAAK,CAACrC,IAAI,CAACG,KAAK,CAAC;YAC7B;UACF,CAAC,CAAC,OAAOqD,CAAC,EAAE;YACVpD,OAAO,CAACD,KAAK,CAAC,6BAA6B,EAAEqD,CAAC,EAAEN,IAAI,CAAC;UACvD;QACF;MACF;;MAEA;MACA,IAAIR,SAAS,EAAE;QACbtC,OAAO,CAAC6B,GAAG,CAAC,iCAAiC,EAAES,SAAS,CAAC;QACzDlD,mBAAmB,CAAC,IAAI,CAAC;;QAEzB;QACA,MAAMiE,eAAe,GAAG,MAAM5D,KAAK,CAAC,uCAAuCoB,SAAS,EAAE,EAAE;UACtFnB,OAAO,EAAEL,aAAa,CAAC;QACzB,CAAC,CAAC;QAEF,IAAIgE,eAAe,CAAC1D,EAAE,EAAE;UACtB,MAAMuD,WAAW,GAAG,MAAMG,eAAe,CAACxD,IAAI,CAAC,CAAC;UAChDG,OAAO,CAAC6B,GAAG,CAAC,qBAAqB,EAAEqB,WAAW,CAAC;UAC/ClE,WAAW,CAACkE,WAAW,CAACnE,QAAQ,IAAI,EAAE,CAAC;QACzC,CAAC,MAAM;UACLiB,OAAO,CAACD,KAAK,CAAC,iCAAiC,EAAEsD,eAAe,CAACrB,MAAM,CAAC;QAC1E;MACF;IACF,CAAC,CAAC,OAAOjC,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;;MAE9C;MACAX,mBAAmB,CAAC,IAAI,CAAC;MACzBJ,WAAW,CAACyC,IAAI,IAAI,CAClB,GAAGA,IAAI,EACP;QACEvB,EAAE,EAAE,SAASkB,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE;QACzBJ,OAAO,EAAE,UAAUlB,KAAK,CAAC+B,OAAO,IAAI,6CAA6C,EAAE;QACnFR,IAAI,EAAE,WAAW;QACjBC,UAAU,EAAE,IAAIH,IAAI,CAAC,CAAC,CAACI,WAAW,CAAC;MACrC,CAAC,CACF,CAAC;IACJ;EACF,CAAC;EAED,oBACEhD,OAAA;IAAK8E,SAAS,EAAC,aAAa;IAAAC,QAAA,gBAC1B/E,OAAA,CAACN,OAAO;MACNS,QAAQ,EAAEA,QAAS;MACnBE,cAAc,EAAEA,cAAe;MAC/B2E,eAAe,EAAErD,mBAAoB;MACrCsD,YAAY,EAAEpD,gBAAiB;MAC/BqD,eAAe,EAAE9C,mBAAoB;MACrC3B,SAAS,EAAEA;IAAU;MAAA0E,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACtB,CAAC,eACFtF,OAAA;MAAK8E,SAAS,EAAC,WAAW;MAAAC,QAAA,gBACxB/E,OAAA,CAACL,UAAU;QACTU,cAAc,EAAEA;MAAe;QAAA8E,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAChC,CAAC,eACFtF,OAAA,CAACJ,UAAU;QACTW,QAAQ,EAAEA,QAAS;QACnBI,gBAAgB,EAAEA,gBAAiB;QACnCN,cAAc,EAAEA,cAAe;QAC/BI,SAAS,EAAEA;MAAU;QAAA0E,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OACtB,CAAC,eACFtF,OAAA,CAACH,YAAY;QAAC0F,aAAa,EAAE/C;MAAkB;QAAA2C,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAE,CAAC;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAC/C,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACH,CAAC;AAEV,CAAC;AAACpF,EAAA,CAjSID,UAAU;EAAA,QAOYH,OAAO;AAAA;AAAA0F,EAAA,GAP7BvF,UAAU;AAmShB,eAAeA,UAAU;AAAC,IAAAuF,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}